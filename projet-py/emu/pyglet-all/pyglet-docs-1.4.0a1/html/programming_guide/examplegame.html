<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>In-depth game example &mdash; pyglet v1.4.0a1</title>
    
    <link rel="stylesheet" href="../_static/pyglet.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.4.0a1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="pyglet v1.4.0a1" href="../index.html" />
    <link rel="next" title="pyglet" href="../modules/pyglet.html" />
    <link rel="prev" title="Advanced topics" href="advanced.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../modules/pyglet.html" title="pyglet"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="advanced.html" title="Advanced topics"
             accesskey="P">previous</a> |</li>
		<li><a href="http://pyglet.org/">pyglet.org</a> |</li>
		<li><a href="../index.html">Documentation Index</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="in-depth-game-example">
<span id="programming-guide-game"></span><h1>In-depth game example<a class="headerlink" href="#in-depth-game-example" title="Permalink to this headline">¶</a></h1>
<p>This tutorial will walk you through the steps of writing a simple Asteroids clone.
It is assumed that the reader is familiar with writing and running Python programs.  This
is not a programming tutorial, but it should hopefully be clear enough to follow even if
you’re a beginner.  If you get stuck, first have a look at the relevant sections of the
programming guide.  The full source code can also be found in the <cite>examples/game/</cite> folder
of the pyglet source directory, which you can follow along with.  If anything is still not
clear, let us know!</p>
<div class="section" id="basic-graphics">
<h2>Basic graphics<a class="headerlink" href="#basic-graphics" title="Permalink to this headline">¶</a></h2>
<p>Lets begin!  The first version of our game will simply show a score of zero, a label
showing the name of the program, three randomly placed asteroids, and the player’s ship.
Nothing will move.</p>
<div class="section" id="setting-up">
<h3>Setting up<a class="headerlink" href="#setting-up" title="Permalink to this headline">¶</a></h3>
<p>First things first, make sure you have pyglet installed.  Then, we will set up the folder
structure for our project.  Since this example game is written in stages, we will have several
<cite>version</cite> folders at various stages of development.  We will also have a shared resource folder
with the images, called ‘resources,’ outside of the example folders.  Each <cite>version</cite> folder
contains a Python file called <cite>asteroid.py</cite> which runs the game, as well as a sub-folder named
<cite>game</cite> where we will place additional modules; this is where most of the logic will be.
Your folder structure should look like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">game</span><span class="o">/</span>
    <span class="n">resources</span><span class="o">/</span>
        <span class="p">(</span><span class="n">images</span> <span class="n">go</span> <span class="n">here</span><span class="p">)</span>
    <span class="n">version1</span><span class="o">/</span>
        <span class="n">asteroid</span><span class="o">.</span><span class="n">py</span>
        <span class="n">game</span><span class="o">/</span>
            <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
</div>
<div class="section" id="getting-a-window">
<h3>Getting a window<a class="headerlink" href="#getting-a-window" title="Permalink to this headline">¶</a></h3>
<p>To set up a window, simply <cite>import pyglet</cite>, create a new instance of <a class="reference internal" href="../modules/window.html#pyglet.window.Window" title="pyglet.window.Window"><code class="xref py py-class docutils literal"><span class="pre">pyglet.window.Window</span></code></a>,
and call <cite>pyglet.app.run()</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyglet</span>
<span class="n">game_window</span> <span class="o">=</span> <span class="n">pyglet</span><span class="o">.</span><span class="n">window</span><span class="o">.</span><span class="n">Window</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">pyglet</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>If you run the code above, you should see a window full of junk that goes away when
you press Esc.  (What you are seeing is raw uninitialized graphics memory).</p>
</div>
<div class="section" id="loading-and-displaying-an-image">
<h3>Loading and displaying an image<a class="headerlink" href="#loading-and-displaying-an-image" title="Permalink to this headline">¶</a></h3>
<p>Since our images will reside in a directory other than the example’s root directory,
we need to tell pyglet where to find them:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyglet</span>
<span class="n">pyglet</span><span class="o">.</span><span class="n">resource</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;../resources&#39;</span><span class="p">]</span>
<span class="n">pyglet</span><span class="o">.</span><span class="n">resource</span><span class="o">.</span><span class="n">reindex</span><span class="p">()</span>
</pre></div>
</div>
<p>pyglet’s <a class="reference internal" href="../modules/resource.html#module-pyglet.resource" title="pyglet.resource"><code class="xref py py-mod docutils literal"><span class="pre">pyglet.resource</span></code></a> module takes all of the hard work out of finding and loading
game resources such as images, sounds, etc..  All that you need to do is tell it where to look,
and reindex it.  In this example game, the resource path starts with <cite>../</cite> because the resources
folder is on the same level as the <cite>version1</cite> folder.  If we left it off, pyglet would look inside
<cite>version1/</cite> for the <cite>resources/</cite> folder.</p>
<p>Now that pyglet’s resource module is initialized, we can easily load the images with the
<a class="reference internal" href="../modules/resource.html#pyglet.resource.image" title="pyglet.resource.image"><code class="xref py py-func docutils literal"><span class="pre">image()</span></code></a> function of the resource module:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">player_image</span> <span class="o">=</span> <span class="n">pyglet</span><span class="o">.</span><span class="n">resource</span><span class="o">.</span><span class="n">image</span><span class="p">(</span><span class="s2">&quot;player.png&quot;</span><span class="p">)</span>
<span class="n">bullet_image</span> <span class="o">=</span> <span class="n">pyglet</span><span class="o">.</span><span class="n">resource</span><span class="o">.</span><span class="n">image</span><span class="p">(</span><span class="s2">&quot;bullet.png&quot;</span><span class="p">)</span>
<span class="n">asteroid_image</span> <span class="o">=</span> <span class="n">pyglet</span><span class="o">.</span><span class="n">resource</span><span class="o">.</span><span class="n">image</span><span class="p">(</span><span class="s2">&quot;asteroid.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="centering-the-images">
<h3>Centering the images<a class="headerlink" href="#centering-the-images" title="Permalink to this headline">¶</a></h3>
<p>Pyglet will draw and position all images from their lower left corner by default.  We don’t
want this behavior for our images, which need to rotate around their centers.  All we have to
do to achieve this is to set their anchor points.  Lets create a function to simplify this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">center_image</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sets an image&#39;s anchor point to its center&quot;&quot;&quot;</span>
    <span class="n">image</span><span class="o">.</span><span class="n">anchor_x</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">width</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">image</span><span class="o">.</span><span class="n">anchor_y</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">height</span> <span class="o">//</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Now we can just call center_image() on all of our loaded images:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">center_image</span><span class="p">(</span><span class="n">player_image</span><span class="p">)</span>
<span class="n">center_image</span><span class="p">(</span><span class="n">bullet_image</span><span class="p">)</span>
<span class="n">center_image</span><span class="p">(</span><span class="n">asteroid_image</span><span class="p">)</span>
</pre></div>
</div>
<p>Remember that the center_image() function must be defined before it can be called at the
module level.  Also, note that zero degrees points directly to the right in pyglet, so the
images are all drawn with their front pointing to the right.</p>
<p>To access the images from asteroid.py, we need to use something like
<cite>from game import resources</cite>, which we’ll get into in the next section.</p>
</div>
<div class="section" id="initializing-objects">
<h3>Initializing objects<a class="headerlink" href="#initializing-objects" title="Permalink to this headline">¶</a></h3>
<p>We want to put some labels at the top of the window to give the player some information about
the score and the current difficulty level.  Eventually, we will have a score display, the name
of the level, and a row of icons representing the number of remaining lives.</p>
</div>
<div class="section" id="making-the-labels">
<h3>Making the labels<a class="headerlink" href="#making-the-labels" title="Permalink to this headline">¶</a></h3>
<p>To make a text label in pyglet, just initialize a <a class="reference internal" href="../modules/text/index.html#pyglet.text.Label" title="pyglet.text.Label"><code class="xref py py-class docutils literal"><span class="pre">pyglet.text.Label</span></code></a> object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">score_label</span> <span class="o">=</span> <span class="n">pyglet</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s2">&quot;Score: 0&quot;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">575</span><span class="p">)</span>
<span class="n">level_label</span> <span class="o">=</span> <span class="n">pyglet</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s2">&quot;My Amazing Game&quot;</span><span class="p">,</span>
                                <span class="n">x</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">575</span><span class="p">,</span> <span class="n">anchor_x</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice that the second label is centered using the anchor_x attribute.</p>
</div>
<div class="section" id="drawing-the-labels">
<h3>Drawing the labels<a class="headerlink" href="#drawing-the-labels" title="Permalink to this headline">¶</a></h3>
<p>We want pyglet to run some specific code whenever the window is drawn.
An <a class="reference internal" href="../modules/window.html#pyglet.window.Window.on_draw" title="pyglet.window.Window.on_draw"><code class="xref py py-meth docutils literal"><span class="pre">on_draw()</span></code></a> event is dispatched to the window to
give it a chance to redraw its contents.  pyglet provides several ways to attach
event handlers to objects; a simple way is to use a decorator:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@game_window</span><span class="o">.</span><span class="n">event</span>
<span class="k">def</span> <span class="nf">on_draw</span><span class="p">():</span>
    <span class="c1"># draw things here</span>
</pre></div>
</div>
<p>The <cite>&#64;game_window.event</cite> decorator lets the Window instance know that our <cite>on_draw()</cite>
function is an event handler.  The <a class="reference internal" href="../modules/window.html#pyglet.window.Window.on_draw" title="pyglet.window.Window.on_draw"><code class="xref py py-meth docutils literal"><span class="pre">on_draw()</span></code></a> event is fired
whenever - you guessed it - the window needs to be redrawn.  Other events include
<a class="reference internal" href="../modules/window.html#pyglet.window.Window.on_mouse_press" title="pyglet.window.Window.on_mouse_press"><code class="xref py py-meth docutils literal"><span class="pre">on_mouse_press()</span></code></a> and <a class="reference internal" href="../modules/window.html#pyglet.window.Window.on_key_press" title="pyglet.window.Window.on_key_press"><code class="xref py py-meth docutils literal"><span class="pre">on_key_press()</span></code></a>.</p>
<p>Now we can fill the method with the functions necessary to draw our labels.
Before we draw anything, we should clear the screen.  After that, we can simply call each
object’s draw() function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@game_window</span><span class="o">.</span><span class="n">event</span>
<span class="k">def</span> <span class="nf">on_draw</span><span class="p">():</span>
    <span class="n">game_window</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="n">level_label</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
    <span class="n">score_label</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
<p>Now when you run asteroid.py, you should get a window with a score of zero in the upper left
corner and a centered label reading “Version 1: Static Graphics” at the top of the screen.</p>
</div>
<div class="section" id="making-the-player-and-asteroid-sprites">
<h3>Making the player and asteroid sprites<a class="headerlink" href="#making-the-player-and-asteroid-sprites" title="Permalink to this headline">¶</a></h3>
<p>The player should be an instance or subclass of <a class="reference internal" href="../modules/sprite.html#pyglet.sprite.Sprite" title="pyglet.sprite.Sprite"><code class="xref py py-class docutils literal"><span class="pre">pyglet.sprite.Sprite</span></code></a>, like so:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">game</span> <span class="k">import</span> <span class="n">resources</span>
<span class="o">...</span>
<span class="n">player_ship</span> <span class="o">=</span> <span class="n">pyglet</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">Sprite</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">resources</span><span class="o">.</span><span class="n">player_image</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
</pre></div>
</div>
<p>To get the player to draw on the screen, add a line to <cite>on_draw()</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@game_window</span><span class="o">.</span><span class="n">event</span>
<span class="k">def</span> <span class="nf">on_draw</span><span class="p">():</span>
    <span class="o">...</span>
    <span class="n">player_ship</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
<p>Loading the asteroids is a little more complicated, since we’ll need to place more than one
at random locations that don’t immediately collide with the player.  Let’s put the loading code
in a new game submodule called load.py:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyglet</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">resources</span>

<span class="k">def</span> <span class="nf">asteroids</span><span class="p">(</span><span class="n">num_asteroids</span><span class="p">):</span>
    <span class="n">asteroids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_asteroids</span><span class="p">):</span>
        <span class="n">asteroid_x</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">800</span><span class="p">)</span>
        <span class="n">asteroid_y</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">600</span><span class="p">)</span>
        <span class="n">new_asteroid</span> <span class="o">=</span> <span class="n">pyglet</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">Sprite</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">resources</span><span class="o">.</span><span class="n">asteroid_image</span><span class="p">,</span>
                                            <span class="n">x</span><span class="o">=</span><span class="n">asteroid_x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">asteroid_y</span><span class="p">)</span>
        <span class="n">new_asteroid</span><span class="o">.</span><span class="n">rotation</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">)</span>
        <span class="n">asteroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_asteroid</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">asteroids</span>
</pre></div>
</div>
<p>All we are doing here is making a few new sprites with random positions.  There’s still a problem,
though - an asteroid might randomly be placed exactly where the player is, causing immediate death.
To fix this issue, we’ll need to be able to tell how far away new asteroids are from the player.
Here is a simple function to calculate that distance:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="o">...</span>
<span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">point_1</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">point_2</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;Returns the distance between two points&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">point_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">point_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">point_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">point_2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>To check new asteroids against the player’s position, we need to pass the player’s position
into the <cite>asteroids()</cite> function and keep regenerating new coordinates until the asteroid is
far enough away.  pyglet sprites keep track of their position both as a tuple (Sprite.position)
and as x and y attributes (Sprite.x and Sprite.y).  To keep our code short, we’ll just pass the
position tuple into the function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">asteroids</span><span class="p">(</span><span class="n">num_asteroids</span><span class="p">,</span> <span class="n">player_position</span><span class="p">):</span>
    <span class="n">asteroids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_asteroids</span><span class="p">):</span>
        <span class="n">asteroid_x</span><span class="p">,</span> <span class="n">asteroid_y</span> <span class="o">=</span> <span class="n">player_position</span>
        <span class="k">while</span> <span class="n">distance</span><span class="p">((</span><span class="n">asteroid_x</span><span class="p">,</span> <span class="n">asteroid_y</span><span class="p">),</span> <span class="n">player_position</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">asteroid_x</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">800</span><span class="p">)</span>
            <span class="n">asteroid_y</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">600</span><span class="p">)</span>
        <span class="n">new_asteroid</span> <span class="o">=</span> <span class="n">pyglet</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">Sprite</span><span class="p">(</span>
            <span class="n">img</span><span class="o">=</span><span class="n">resources</span><span class="o">.</span><span class="n">asteroid_image</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">asteroid_x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">asteroid_y</span><span class="p">)</span>
        <span class="n">new_asteroid</span><span class="o">.</span><span class="n">rotation</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">)</span>
        <span class="n">asteroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_asteroid</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">asteroids</span>
</pre></div>
</div>
<p>For each asteroid, it chooses random positions until it finds one away from the player,
creates the sprite, and gives it a random rotation.  Each asteroid is appended to a list,
which is returned.</p>
<p>Now you can load three asteroids like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">game</span> <span class="k">import</span> <span class="n">resources</span><span class="p">,</span> <span class="n">load</span>
<span class="o">...</span>
<span class="n">asteroids</span> <span class="o">=</span> <span class="n">load</span><span class="o">.</span><span class="n">asteroids</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">player_ship</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
</pre></div>
</div>
<p>The asteroids variable now contains a list of sprites.  Drawing them on the screen is as simple
as it was for the player’s ship - just call their :meth:~pyglet.sprite.Sprite.draw` methods:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@game_window</span><span class="o">.</span><span class="n">event</span>
<span class="k">def</span> <span class="nf">on_draw</span><span class="p">():</span>
    <span class="o">...</span>
    <span class="k">for</span> <span class="n">asteroid</span> <span class="ow">in</span> <span class="n">asteroids</span><span class="p">:</span>
        <span class="n">asteroid</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
<p>This wraps up the first section.  Your “game” doesn’t do much of anything yet, but we’ll get
to that in the following sections.  You may want to look over the <cite>examples/game/version1</cite>
folder in the pyglet source to review what we’ve done, and to find a functional copy.</p>
</div>
</div>
<div class="section" id="basic-motion">
<h2>Basic motion<a class="headerlink" href="#basic-motion" title="Permalink to this headline">¶</a></h2>
<p>In the second version of the example, we’ll introduce a simpler, faster way to draw all of the
game objects, as well as add row of icons indicating the number of lives left.  We’ll also write
some code to make the player and the asteroids obey the laws of physics.</p>
<div class="section" id="drawing-with-batches">
<h3>Drawing with batches<a class="headerlink" href="#drawing-with-batches" title="Permalink to this headline">¶</a></h3>
<p>Calling each object’s <cite>draw()</cite> method manually can become cumbersome and tedious if there are many
different kinds of objects.  It’s also very inefficient if you need to draw a large number of
objects.  The pyglet <a class="reference internal" href="../modules/graphics/index.html#pyglet.graphics.Batch" title="pyglet.graphics.Batch"><code class="xref py py-class docutils literal"><span class="pre">pyglet.graphics.Batch</span></code></a> class simplifies drawing by letting you draw
all your objects with a single function call.  All you need to do is create a batch, pass it into
each object you want to draw, and call the batch’s <a class="reference internal" href="../modules/graphics/index.html#pyglet.graphics.Batch.draw" title="pyglet.graphics.Batch.draw"><code class="xref py py-meth docutils literal"><span class="pre">draw()</span></code></a> method.</p>
<p>To create a new batch, simply create an instance of <a class="reference internal" href="../modules/graphics/index.html#pyglet.graphics.Batch" title="pyglet.graphics.Batch"><code class="xref py py-class docutils literal"><span class="pre">pyglet.graphics.Batch</span></code></a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">main_batch</span> <span class="o">=</span> <span class="n">pyglet</span><span class="o">.</span><span class="n">graphics</span><span class="o">.</span><span class="n">Batch</span><span class="p">()</span>
</pre></div>
</div>
<p>To make an object a member of a batch, just pass the batch into its constructor as the batch
keyword argument:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">score_label</span> <span class="o">=</span> <span class="n">pyglet</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s2">&quot;Score: 0&quot;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">575</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="n">main_batch</span><span class="p">)</span>
</pre></div>
</div>
<p>Add the batch keyword argument to each graphical object created in asteroid.py.</p>
<p>To use the batch with the asteroid sprites, we’ll need to pass the batch into the
<cite>game.load.asteroid()</cite> function, then just add it as a keyword argument to each new sprite.
Update the function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">asteroids</span><span class="p">(</span><span class="n">num_asteroids</span><span class="p">,</span> <span class="n">player_position</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">new_asteroid</span> <span class="o">=</span> <span class="n">pyglet</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">Sprite</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">resources</span><span class="o">.</span><span class="n">asteroid_image</span><span class="p">,</span>
                                        <span class="n">x</span><span class="o">=</span><span class="n">asteroid_x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">asteroid_y</span><span class="p">,</span>
                                        <span class="n">batch</span><span class="o">=</span><span class="n">batch</span><span class="p">)</span>
</pre></div>
</div>
<p>And update the place where it’s called:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">asteroids</span> <span class="o">=</span> <span class="n">load</span><span class="o">.</span><span class="n">asteroids</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">player_ship</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">main_batch</span><span class="p">)</span>
</pre></div>
</div>
<p>Now you can replace those five lines of <cite>draw()</cite> calls with just one:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">main_batch</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
<p>Now when you run asteroid.py, it should look exactly the same.</p>
</div>
<div class="section" id="displaying-little-ship-icons">
<h3>Displaying little ship icons<a class="headerlink" href="#displaying-little-ship-icons" title="Permalink to this headline">¶</a></h3>
<p>To show how many lives the player has left, we’ll need to draw a little row of icons in the upper
right corner of the screen.  Since we’ll be making more than one using the same template, let’s
create a function called <cite>player_lives()</cite> in the <cite>load</cite> module to generate them.
The icons should look the same as the player’s ship.  We could create a scaled version using an
image editor, or we could just let pyglet do the scaling.  I don’t know about you, but I prefer
the option that requires less work.</p>
<p>The function for creating the icons is almost exactly the same as the one for creating asteroids.
For each icon we just create a sprite, give it a position and scale, and append it to the return
list:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">player_lives</span><span class="p">(</span><span class="n">num_icons</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">player_lives</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_icons</span><span class="p">):</span>
        <span class="n">new_sprite</span> <span class="o">=</span> <span class="n">pyglet</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">Sprite</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">resources</span><span class="o">.</span><span class="n">player_image</span><span class="p">,</span>
                                          <span class="n">x</span><span class="o">=</span><span class="mi">785</span><span class="o">-</span><span class="n">i</span><span class="o">*</span><span class="mi">30</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">585</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="n">batch</span><span class="p">)</span>
        <span class="n">new_sprite</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">player_lives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_sprite</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">player_lives</span>
</pre></div>
</div>
<p>The player icon is 50x50 pixels, so half that size will be 25x25.  We want to put a little bit of
space between each icon, so we create them at 30-pixel intervals starting from the right side of
the screen and moving to the left.  Note that like the <cite>asteroids()</cite> function, <cite>player_lives()</cite>
takes a <cite>batch</cite> argument.</p>
</div>
<div class="section" id="making-things-move">
<h3>Making things move<a class="headerlink" href="#making-things-move" title="Permalink to this headline">¶</a></h3>
<p>The game would be pretty boring if nothing on the screen ever moved.  To achieve motion, we’ll
need to write our own set of classes to handle frame-by-frame movement calculations.  We’ll also
need to write a Player class to respond to keyboard input.</p>
<p><strong>Creating the basic motion class</strong></p>
<p>Since every visible object is represented by at least one Sprite, we may as well make our basic
motion class a subclass of pyglet.sprite.Sprite.  Another approach would be to have our class
have a sprite attribute.</p>
<p>Create a new game submodule called physicalobject.py and declare a PhysicalObject class.
The only new attributes we’ll be adding will store the object’s velocity, so the constructor will
be simple:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PhysicalObject</span><span class="p">(</span><span class="n">pyglet</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">Sprite</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">velocity_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_y</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
</pre></div>
</div>
<p>Each object will need to be updated every frame, so let’s write an <cite>update()</cite> method.</p>
<blockquote>
<div><dl class="docutils">
<dt>def update(self, dt):</dt>
<dd>self.x += self.velocity_x * dt
self.y += self.velocity_y * dt</dd>
</dl>
</div></blockquote>
<p>What’s dt?  It’s the “delta time”, or “time step”.  Game frames are not instantaneous, and
they don’t always take equal amounts of time to draw.  If you’ve ever tried to play a modern game
on an old machine, you know that frame rates can jump all over the place.  There are a number of
ways to deal with this problem, the simplest one being to just multiply all time-sensitive
operations by dt.  I’ll show you how this value is calculated later.</p>
<p>If we give objects a velocity and just let them go, they will fly off the screen before long.
Since we’re making an Asteroids clone, we would rather they just wrapped around the screen.
Here is a simple function that accomplishes the goal:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">check_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">min_x</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">min_y</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">max_x</span> <span class="o">=</span> <span class="mi">800</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">max_y</span> <span class="o">=</span> <span class="mi">600</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">min_x</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">max_x</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">max_x</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">min_x</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">min_y</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">max_y</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">max_y</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">min_y</span>
</pre></div>
</div>
<p>As you can see, it simply checks to see if objects are no longer visible on the screen, and if so,
it moves them to the other side of the screen.  To make every PhysicalObject use this behavior,
add a call to <cite>self.check_bounds()</cite> at the end of <cite>update()</cite>.</p>
<p>To make the asteroids use our new motion code, just import the physicalobject module and change the
<cite>new_asteroid = …</cite> line to create a new <cite>PhysicalObject</cite> instead of a <cite>Sprite</cite>.  You’ll also want
to give them a random initial velocity.  Here is the new, improved <cite>load.asteroids()</cite> function:</p>
<blockquote>
<div><dl class="docutils">
<dt>def asteroids(num_asteroids, player_position, batch=None):</dt>
<dd>…
new_asteroid = physicalobject.PhysicalObject(…)
new_asteroid.rotation = random.randint(0, 360)
new_asteroid.velocity_x = random.random()*40
new_asteroid.velocity_y = random.random()*40
…</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="writing-the-game-update-function">
<h3>Writing the game update function<a class="headerlink" href="#writing-the-game-update-function" title="Permalink to this headline">¶</a></h3>
<p>To call each object’s <cite>update()</cite> method every frame, we first need to have a list of those objects.
For now, we can just declare it after setting up all the other objects:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">game_objects</span> <span class="o">=</span> <span class="p">[</span><span class="n">player_ship</span><span class="p">]</span> <span class="o">+</span> <span class="n">asteroids</span>
</pre></div>
</div>
<p>Now we can write a simple function to iterate over the list:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">game_objects</span><span class="p">:</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p>The <cite>update()</cite> function takes a <cite>dt</cite> parameter because it is still not the source of the actual time
step.</p>
</div>
<div class="section" id="calling-the-update-function">
<h3>Calling the update() function<a class="headerlink" href="#calling-the-update-function" title="Permalink to this headline">¶</a></h3>
<p>We need to update the objects at least once per frame.  What’s a frame?  Well, most screens have a
maximum refresh rate of 60 hertz.  If we set our loop to run at exactly 60 hertz, though, the motion
will look a little jerky because it won’t match the screen exactly.  Instead, we can have it
update twice as fast, 120 times per second, to get smooth animation.</p>
<p>The best way to call a function 120 times per second is to ask pyglet to do it.  The
<a class="reference internal" href="../modules/clock.html#module-pyglet.clock" title="pyglet.clock"><code class="xref py py-mod docutils literal"><span class="pre">pyglet.clock</span></code></a> module contains a number of ways to call functions periodically or at some
specified time in the future.  The one we want is <a class="reference internal" href="../modules/clock.html#pyglet.clock.schedule_interval" title="pyglet.clock.schedule_interval"><code class="xref py py-meth docutils literal"><span class="pre">pyglet.clock.schedule_interval()</span></code></a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">pyglet</span><span class="o">.</span><span class="n">clock</span><span class="o">.</span><span class="n">schedule_interval</span><span class="p">(</span><span class="n">update</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mf">120.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Putting this line above <cite>pyglet.app.run()</cite> in the if <cite>__name__ == ‘__main__’</cite> block tells pyglet to
call <cite>update()</cite> 120 times per second.  Pyglet will pass in the elapsed time, i.e. <cite>dt</cite>, as the only
parameter.</p>
<p>Now when you run asteroid.py, you should see your formerly static asteroids drifting serenely
across the screen, reappearing on the other side when they slide off the edge.</p>
</div>
<div class="section" id="writing-the-player-class">
<h3>Writing the Player class<a class="headerlink" href="#writing-the-player-class" title="Permalink to this headline">¶</a></h3>
<p>In addition to obeying the basic laws of physics, the player object needs to respond to keyboard
input.  Start by creating a <cite>game.player</cite> module, importing the appropriate modules, and subclassing
<cite>PhysicalObject</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">physicalobject</span><span class="p">,</span> <span class="n">resources</span>


<span class="k">class</span> <span class="nc">Player</span><span class="p">(</span><span class="n">physicalobject</span><span class="o">.</span><span class="n">PhysicalObject</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">resources</span><span class="o">.</span><span class="n">player_image</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>So far, the only difference between a Player and a PhysicalObject is that a Player will always have
the same image.  But Player objects need a couple more attributes.  Since the ship will always
thrust with the same force in whatever direction it points, we’ll need to define a constant for the
magnitude of that force.  We should also define a constant for the ship’s rotation speed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">thrust</span> <span class="o">=</span> <span class="mf">300.0</span>
<span class="bp">self</span><span class="o">.</span><span class="n">rotate_speed</span> <span class="o">=</span> <span class="mf">200.0</span>
</pre></div>
</div>
<p>Now we need to get the class to respond to user input.  Pyglet uses an event-based approach to
input, sending key press and key release events to registered event handlers.  But we want to use a
polling approach in this example, checking periodically if a key is down.  One way to accomplish
that is to maintain a dictionary of keys.  First, we need to initialize the dictionary in the
constructor:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">up</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we need to write two methods, <cite>on_key_press()</cite> and <cite>on_key_release()</cite>.  When pyglet checks a
new event handler, it looks for these two methods, among others.</p>
<blockquote>
<div><p>import math
from pyglet.window import key
from . import physicalobject, resources</p>
<p>class Player(physicalobject.PhysicalObject)</p>
<blockquote>
<div><dl class="docutils">
<dt>def on_key_press(self, symbol, modifiers):</dt>
<dd><dl class="first last docutils">
<dt>if symbol == key.UP:</dt>
<dd>self.keys[‘up’] = True</dd>
<dt>elif symbol == key.LEFT:</dt>
<dd>self.keys[‘left’] = True</dd>
<dt>elif symbol == key.RIGHT:</dt>
<dd>self.keys[‘right’] = True</dd>
</dl>
</dd>
<dt>def on_key_release(self, symbol, modifiers):</dt>
<dd><dl class="first last docutils">
<dt>if symbol == key.UP:</dt>
<dd>self.keys[‘up’] = False</dd>
<dt>elif symbol == key.LEFT:</dt>
<dd>self.keys[‘left’] = False</dd>
<dt>elif symbol == key.RIGHT:</dt>
<dd>self.keys[‘right’] = False</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>That looks pretty cumbersome. There’s a better way to do it which we’ll see later, but for now,
this version serves as a good demonstration of pyglet’s event system.</p>
<p>The last thing we need to do is write the <cite>update()</cite> method.  It follows the same behavior as a
PhysicalObject plus a little extra, so we’ll need to call PhysicalObject’s <cite>update()`</cite> method and
then respond to input:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">Player</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotation</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_speed</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotation</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_speed</span> <span class="o">*</span> <span class="n">dt</span>
</pre></div>
</div>
<p>Pretty simple so far.  To rotate the player, we just add the rotation speed to the angle, multiplied
by dt to account for time.  Note that Sprite objects’ rotation attributes are in degrees, with
clockwise as the positive direction.  This means that you need to call <cite>math.degrees()</cite> or
<cite>math.radians()</cite> and make the result negative whenever you use Python’s built-in math functions with
the Sprite class, since those functions use radians instead of degrees, and their positive direction
is counter-clockwise.  The code to make the ship thrust forward uses an example of such a
conversion:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">]:</span>
    <span class="n">angle_radians</span> <span class="o">=</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation</span><span class="p">)</span>
    <span class="n">force_x</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle_radians</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">thrust</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="n">force_y</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle_radians</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">thrust</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">velocity_x</span> <span class="o">+=</span> <span class="n">force_x</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">velocity_y</span> <span class="o">+=</span> <span class="n">force_y</span>
</pre></div>
</div>
<p>First, we convert the angle to radians so that <cite>math.cos()</cite> and <cite>math.sin()</cite> will get the correct
values.  Then we apply some simple physics to modify the ship’s X and Y velocity components and push
the ship in the right direction.</p>
<p>We now have a complete Player class.  If we add it to the game and tell pyglet that it’s an event
handler, we should be good to go.</p>
</div>
<div class="section" id="integrating-the-player-class">
<h3>Integrating the player class<a class="headerlink" href="#integrating-the-player-class" title="Permalink to this headline">¶</a></h3>
<p>The first thing we need to do is make player_ship an instance of Player:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">game</span> <span class="k">import</span> <span class="n">player</span>
<span class="o">...</span>
<span class="n">player_ship</span> <span class="o">=</span> <span class="n">player</span><span class="o">.</span><span class="n">Player</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="n">main_batch</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we need to tell pyglet that player_ship is an event handler.  To do that, we need to push it
onto the event stack with <cite>game_window.push_handlers()</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">game_window</span><span class="o">.</span><span class="n">push_handlers</span><span class="p">(</span><span class="n">player_ship</span><span class="p">)</span>
</pre></div>
</div>
<p>That’s it! Now you should be able to run the game and move the player with the arrow keys.</p>
</div>
</div>
<div class="section" id="giving-the-player-something-to-do">
<h2>Giving the player something to do<a class="headerlink" href="#giving-the-player-something-to-do" title="Permalink to this headline">¶</a></h2>
<p>In any good game, there needs to be something working against the player. In the case of Asteroids,
it’s the threat of collision with, well, an asteroid.  Collision detection requires a lot of
infrastructure in the code, so this section will focus on making it work.  We’ll also clean up the
player class and show some visual feedback for thrusting.</p>
<div class="section" id="simplifying-player-input">
<h3>Simplifying player input<a class="headerlink" href="#simplifying-player-input" title="Permalink to this headline">¶</a></h3>
<p>Right now, the Player class handles all of its own keyboard events.  It spends 13 lines of code
doing nothing but setting boolean values in a dictionary.  One would think that there would be a
better way, and there is: <a class="reference internal" href="../modules/window_key.html#pyglet.window.key.KeyStateHandler" title="pyglet.window.key.KeyStateHandler"><code class="xref py py-class docutils literal"><span class="pre">pyglet.window.key.KeyStateHandler</span></code></a>.  This handy class
automatically does what we have been doing manually: it tracks the state of every key on the
keyboard.</p>
<p>To start using it, we need to initialize it and push it onto the event stack instead of the Player
class.  First, let’s add it to Player‘s constructor:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">key_handler</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">KeyStateHandler</span><span class="p">()</span>
</pre></div>
</div>
<p>We also need to push the key_handler object onto the event stack.  Keep pushing the player_ship
object in addition to its key handler, because we’ll need it to keep handling key press and release
events later:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">game_window</span><span class="o">.</span><span class="n">push_handlers</span><span class="p">(</span><span class="n">player_ship</span><span class="o">.</span><span class="n">key_handler</span><span class="p">)</span>
</pre></div>
</div>
<p>Since Player now relies on key_handler to read the keyboard, we need to change the <cite>update()</cite> method
to use it.  The only changes are in the if conditions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_handler</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">LEFT</span><span class="p">]:</span>
    <span class="o">...</span>
<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_handler</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">RIGHT</span><span class="p">]:</span>
    <span class="o">...</span>
<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_handler</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">UP</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Now we can remove the <cite>on_key_press()</cite> and <cite>on_key_release()</cite> methods from the class.  It’s just
that simple.  If you need to see a list of key constants, you can check the API documentation under
<a class="reference internal" href="../modules/window_key.html#module-pyglet.window.key" title="pyglet.window.key"><code class="xref py py-class docutils literal"><span class="pre">pyglet.window.key</span></code></a>.</p>
</div>
<div class="section" id="adding-an-engine-flame">
<h3>Adding an engine flame<a class="headerlink" href="#adding-an-engine-flame" title="Permalink to this headline">¶</a></h3>
<p>Without visual feedback, it can be difficult to tell if the ship is actually thrusting forward or
not, especially for an observer just watching someone else play the game.  One way to provide visual
feedback is to show an engine flame behind the player while the player is thrusting.</p>
</div>
<div class="section" id="loading-the-flame-image">
<h3>Loading the flame image<a class="headerlink" href="#loading-the-flame-image" title="Permalink to this headline">¶</a></h3>
<p>The player will now be made of two sprites.  There’s nothing preventing us from letting a Sprite
own another Sprite, so we’ll just give Player an engine_sprite attribute and update it every frame.
For our purposes, this approach will be the simplest and most scalable.</p>
<p>To make the flame draw in the correct position, we could either do some complicated math every
frame, or we could just move the image’s anchor point. First, load the image in resources.py:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">engine_image</span> <span class="o">=</span> <span class="n">pyglet</span><span class="o">.</span><span class="n">resource</span><span class="o">.</span><span class="n">image</span><span class="p">(</span><span class="s2">&quot;engine_flame.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>To get the flame to draw behind the player, we need to move the flame image’s center of rotation to
the right, past the end of the image.  To do that, we just set its <cite>anchor_x</cite> and <cite>anchor_y</cite>
attributes:</p>
<blockquote>
<div>engine_image.anchor_x = engine_image.width * 1.5
engine_image.anchor_y = engine_image.height / 2</div></blockquote>
<p>Now the image is ready to be used by the player class.  If you’re still confused about anchor
points, experiment with the values for engine_image’s anchor point when you finish this section.</p>
</div>
<div class="section" id="creating-and-drawing-the-flame">
<h3>Creating and drawing the flame<a class="headerlink" href="#creating-and-drawing-the-flame" title="Permalink to this headline">¶</a></h3>
<p>The engine sprite needs to be initialized with all the same arguments as Player, except that it
needs a different image and must be initially invisible.  The code for creating it belongs in
<cite>Player.__init__()</cite> and is very straightforward:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">engine_sprite</span> <span class="o">=</span> <span class="n">pyglet</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">Sprite</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">resources</span><span class="o">.</span><span class="n">engine_image</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">engine_sprite</span><span class="o">.</span><span class="n">visible</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
<p>To make the engine sprite appear only while the player is thrusting, we need to add some logic to
the if <cite>self.key_handler[key.UP]</cite> block in the <cite>update()</cite> method:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_handler</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">UP</span><span class="p">]:</span>
    <span class="o">...</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">engine_sprite</span><span class="o">.</span><span class="n">visible</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">else</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">engine_sprite</span><span class="o">.</span><span class="n">visible</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
<p>To make the sprite appear at the player’s position, we also need to update its position and
rotation attributes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_handler</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">UP</span><span class="p">]:</span>
    <span class="o">...</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">engine_sprite</span><span class="o">.</span><span class="n">rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">engine_sprite</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">engine_sprite</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">engine_sprite</span><span class="o">.</span><span class="n">visible</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">else</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">engine_sprite</span><span class="o">.</span><span class="n">visible</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
<div class="section" id="cleaning-up-after-death">
<h3>Cleaning up after death<a class="headerlink" href="#cleaning-up-after-death" title="Permalink to this headline">¶</a></h3>
<p>When the player is inevitably smashed to bits by an asteroid, he will disappear from the screen.
However, simply removing the Player instance from the game_objects list is not enough for it to be
removed from the graphics batch.  To do that, we need to call its <cite>delete()</cite> method.  Normally a
Sprite‘s own <cite>delete()</cite> method will work fine without modifications, but our subclass has its own
child Sprite (the engine flame) which must also be deleted when the Player instance is deleted.
To get both to die gracefully, we must write a simple but slightly enhanced <cite>delete()</cite> method:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">engine_sprite</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">Player</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
<p>The Player class is now cleaned up and ready to go.</p>
</div>
<div class="section" id="checking-for-collisions">
<h3>Checking For collisions<a class="headerlink" href="#checking-for-collisions" title="Permalink to this headline">¶</a></h3>
<p>To make objects disappear from the screen, we’ll need to manipulate the game_objects list.
Every object will need to check every other object’s position against its own, and each object will
have to decide whether or not it should be removed from the list.  The game loop will then check for
dead objects and remove them from the list.</p>
</div>
<div class="section" id="checking-all-object-pairs">
<h3>Checking all object pairs<a class="headerlink" href="#checking-all-object-pairs" title="Permalink to this headline">¶</a></h3>
<p>We need to check every object against every other object.  The simplest method is to use nested
loops.  This method will be inefficient for a large number of objects, but it will work for our
purposes.  We can use one easy optimization and avoid checking the same pair of objects twice.
Here’s the setup for the loops, which belongs in <cite>update()</cite>.  It simply iterates over all object
pairs without doing anything:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">game_objects</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">game_objects</span><span class="p">)):</span>
        <span class="n">obj_1</span> <span class="o">=</span> <span class="n">game_objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">obj_2</span> <span class="o">=</span> <span class="n">game_objects</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<p>We’ll need a way to check if an object has already been killed.  We could go over to PhysicalObject
right now and put it in, but let’s keep working on the game loop and implement the method later.
For now, we’ll just assume that everything in game_objects has a dead attribute which will be False
until the class sets it to True, at which point it will be ignored and eventually removed from the
list.</p>
<p>To perform the actual check, we’ll also need to call two more methods that don’t exist yet.
One method will determine if the two objects actually collide, and the other method will give each
object an opportunity to respond to the collision.  The checking code itself is easy to understand,
so I won’t bother you with further explanations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="ow">not</span> <span class="n">obj_1</span><span class="o">.</span><span class="n">dead</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">obj_2</span><span class="o">.</span><span class="n">dead</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">obj_1</span><span class="o">.</span><span class="n">collides_with</span><span class="p">(</span><span class="n">obj_2</span><span class="p">):</span>
        <span class="n">obj_1</span><span class="o">.</span><span class="n">handle_collision_with</span><span class="p">(</span><span class="n">obj_2</span><span class="p">)</span>
        <span class="n">obj_2</span><span class="o">.</span><span class="n">handle_collision_with</span><span class="p">(</span><span class="n">obj_1</span><span class="p">)</span>
</pre></div>
</div>
<p>Now all that remains is for us to go through the list and remove dead objects:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">to_remove</span> <span class="ow">in</span> <span class="p">[</span><span class="n">obj</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">game_objects</span> <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">dead</span><span class="p">]:</span>
    <span class="n">to_remove</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
    <span class="n">game_objects</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span>
</pre></div>
</div>
<p>As you can see, it simply calls the object’s <cite>delete()</cite> method to remove it from any batches, then
it removes it from the list.  If you haven’t used list comprehensions much, the above code might
look like it’s removing objects from the list while traversing it.  Fortunately, the list
comprehension is evaluated before the loop actually runs, so there should be no problems.</p>
</div>
<div class="section" id="implementing-the-collision-functions">
<h3>Implementing the collision functions<a class="headerlink" href="#implementing-the-collision-functions" title="Permalink to this headline">¶</a></h3>
<p>We need to add three things to the PhysicalObject class: the dead attribute, the <cite>collides_with()</cite>
method, and the <cite>handle_collision_with()</cite> method.  The <cite>collides_with()</cite> method will need to use
the <cite>distance()</cite> function, so let’s start by moving that function into its own submodule of game,
called util.py:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyglet</span><span class="o">,</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">point_1</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">point_2</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
        <span class="p">(</span><span class="n">point_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">point_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
        <span class="p">(</span><span class="n">point_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">point_2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Remember to call from util import distance in load.py.  Now we can write
<cite>PhysicalObject.collides_with()</cite> without duplicating code:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">collides_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_object</span><span class="p">):</span>
    <span class="n">collision_distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">other_object</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">actual_distance</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">other_object</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">actual_distance</span> <span class="o">&lt;=</span> <span class="n">collision_distance</span><span class="p">)</span>
</pre></div>
</div>
<p>The collision handler function is even simpler, since for now we just want every object to die as
soon as it touches another object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">handle_collision_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_object</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dead</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p>One last thing: set self.dead = False in PhysicalObject.__init__().</p>
<p>And that’s it! You should be able to zip around the screen, engine blazing away.  If you hit
something, both you and the thing you collided with should disappear from the screen.  There’s
still no game, but we are clearly making progress.</p>
</div>
</div>
<div class="section" id="collision-response">
<h2>Collision response<a class="headerlink" href="#collision-response" title="Permalink to this headline">¶</a></h2>
<p>In this section, we’ll add bullets.  This new feature will require us to start adding things to
the game_objects list during the game, as well as have objects check each others’ types to make a
decision about whether or not they should die.</p>
<div class="section" id="adding-objects-during-play">
<h3>Adding objects during play<a class="headerlink" href="#adding-objects-during-play" title="Permalink to this headline">¶</a></h3>
<p><strong>How?</strong></p>
<p>We handled object removal with a boolean flag.  Adding objects will be a little bit more
complicated.  For one thing, an object can’t just say “Add me to the list!”  It has to come from
somewhere.  For another thing, an object might want to add more than one other object at a time.</p>
<p>There are a few ways to solve this problem.  To avoid circular references, keep our constructors
nice and short, and avoid adding extra modules, we’ll have each object keep a list of new child
objects to be added to game_objects.  This approach will make it easy for any object in the game
to spawn more objects.</p>
</div>
<div class="section" id="tweaking-the-game-loop">
<h3>Tweaking the game loop<a class="headerlink" href="#tweaking-the-game-loop" title="Permalink to this headline">¶</a></h3>
<p>The simplest way to check objects for children and add those children to the list is to add two
lines of code to the game_objects loop.  We haven’t implemented the new_objects attribute yet,
but when we do, it will be a list of objects to add:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">game_objects</span><span class="p">:</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">game_objects</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">new_objects</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">new_objects</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
<p>Unfortunately, this simple solution is problematic.  It’s generally a bad idea to modify a list
while iterating over it.  The fix is to simply add new objects to a separate list, then add the
objects in the separate list to game_objects after we have finished iterating over it.</p>
<p>Declare a to_add list just below the loop and add new objects to it instead.  At the very bottom
of <cite>update()</cite>, after the object removal code, add the objects in to_add to game_objects:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">...</span><span class="n">collision</span><span class="o">...</span>

<span class="n">to_add</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">game_objects</span><span class="p">:</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">to_add</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">new_objects</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">new_objects</span> <span class="o">=</span> <span class="p">[]</span>

<span class="o">...</span><span class="n">removal</span><span class="o">...</span>

<span class="n">game_objects</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">to_add</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="putting-the-attribute-in-physicalobject">
<h3>Putting the attribute in PhysicalObject<a class="headerlink" href="#putting-the-attribute-in-physicalobject" title="Permalink to this headline">¶</a></h3>
<p>As mentioned before, all we have to do is declare a new_objects attribute in the PhysicalObject
class:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="o">....</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">new_objects</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
<p>To add a new object, all we have to do is put something in new_objects, and the main loop will
see it, add it to the game_objects list, and clear new_objects.</p>
</div>
<div class="section" id="adding-bullets">
<h3>Adding bullets<a class="headerlink" href="#adding-bullets" title="Permalink to this headline">¶</a></h3>
<p><strong>Writing the bullet class</strong></p>
<p>For the most part, bullets act like any other PhysicalObject, but they have two differences, at
least in this game: they only collide with some objects, and they disappear from the screen after
a couple of seconds to prevent the player from flooding the screen with bullets.</p>
<p>First, make a new submodule of game called bullet.py and start a simple subclass of PhysicalObject:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyglet</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">physicalobject</span><span class="p">,</span> <span class="n">resources</span>

<span class="k">class</span> <span class="nc">Bullet</span><span class="p">(</span><span class="n">physicalobject</span><span class="o">.</span><span class="n">PhysicalObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Bullets fired by the player&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Bullet</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">resources</span><span class="o">.</span><span class="n">bullet_image</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>To get bullets to disappear after a time, we could keep track of our own age and lifespan
attributes, or we could let pyglet do all the work for us.  I don’t know about you, but I prefer
the second option.  First, we need to write a function to call at the end of a bullet’s life:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">die</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dead</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p>Now we need to tell pyglet to call it after half a second or so.  We can do this as soon as the
object is initialized by adding a call to <a class="reference internal" href="../modules/clock.html#pyglet.clock.schedule_once" title="pyglet.clock.schedule_once"><code class="xref py py-meth docutils literal"><span class="pre">pyglet.clock.schedule_once()</span></code></a> to the constructor:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">Bullet</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">resources</span><span class="o">.</span><span class="n">bullet_image</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">pyglet</span><span class="o">.</span><span class="n">clock</span><span class="o">.</span><span class="n">schedule_once</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">die</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>There’s still more work to be done on the Bullet class, but before we do any more work on the
class itself, let’s get them on the screen.</p>
</div>
<div class="section" id="firing-bullets">
<h3>Firing bullets<a class="headerlink" href="#firing-bullets" title="Permalink to this headline">¶</a></h3>
<p>The Player class will be the only class that fires bullets, so let’s open it up, import the bullet
module, and add a bullet_speed attribute to its constructor:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">bullet</span>

<span class="k">class</span> <span class="nc">Player</span><span class="p">(</span><span class="n">physicalobject</span><span class="o">.</span><span class="n">PhysicalObject</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Player</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">resources</span><span class="o">.</span><span class="n">player_image</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bullet_speed</span> <span class="o">=</span> <span class="mf">700.0</span>
</pre></div>
</div>
<p>Now we can write the code to create a new bullet and send it hurling off into space.  First, we
need to resurrect the on_key_press() event handler:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">on_key_press</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">modifiers</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">symbol</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="n">SPACE</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fire</span><span class="p">()</span>
</pre></div>
</div>
<p>The <cite>fire()</cite> method itself will be a bit more complicated.  Most of the calculations will be very
similar to the ones for thrusting, but there will be some differences.  We’ll need to spawn the
bullet out at the nose of the ship, not at its center.  We’ll also need to add the ship’s existing
velocity to the bullet’s new velocity, or the bullets will end up going slower than the ship if the
player gets going fast enough.</p>
<p>As usual, convert to radians and reverse the direction:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fire</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">angle_radians</span> <span class="o">=</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, calculate the bullet’s position and instantiate it:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ship_radius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span>
<span class="n">bullet_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle_radians</span><span class="p">)</span> <span class="o">*</span> <span class="n">ship_radius</span>
<span class="n">bullet_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle_radians</span><span class="p">)</span> <span class="o">*</span> <span class="n">ship_radius</span>
<span class="n">new_bullet</span> <span class="o">=</span> <span class="n">bullet</span><span class="o">.</span><span class="n">Bullet</span><span class="p">(</span><span class="n">bullet_x</span><span class="p">,</span> <span class="n">bullet_y</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch</span><span class="p">)</span>
</pre></div>
</div>
<p>Set its velocity using almost the same equations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bullet_vx</span> <span class="o">=</span> <span class="p">(</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">velocity_x</span> <span class="o">+</span>
    <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle_radians</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bullet_speed</span>
<span class="p">)</span>
<span class="n">bullet_vy</span> <span class="o">=</span> <span class="p">(</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">velocity_y</span> <span class="o">+</span>
    <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle_radians</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bullet_speed</span>
<span class="p">)</span>
<span class="n">new_bullet</span><span class="o">.</span><span class="n">velocity_x</span> <span class="o">=</span> <span class="n">bullet_vx</span>
<span class="n">new_bullet</span><span class="o">.</span><span class="n">velocity_y</span> <span class="o">=</span> <span class="n">bullet_vy</span>
</pre></div>
</div>
<p>Finally, add it to the new_objects list so that the main loop will pick it up and add it to
game_objects:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">new_objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_bullet</span><span class="p">)</span>
</pre></div>
</div>
<p>At this point, you should be able to fire bullets out of the front of your ship.  There’s just one
problem: as soon as you fire, your ship disappears. You may have noticed earlier that asteroids
also disappear when they touch each other.  To fix this problem, we’ll need to start customizing
each class’s <cite>handle_collision_with()</cite> method.</p>
</div>
<div class="section" id="customizing-collision-behavior">
<h3>Customizing collision behavior<a class="headerlink" href="#customizing-collision-behavior" title="Permalink to this headline">¶</a></h3>
<p>There are five kinds of collisions in the current version of the game: bullet-asteroid,
bullet-player, asteroid-player, bullet-bullet, and asteroid-asteroid.  There would be many more
in a more complex game.</p>
<p>In general, objects of the same type should not be destroyed when they collide, so we can
generalize that behavior in PhysicalObject.  Other interactions will require a little more work.</p>
<p><strong>Letting twins ignore each other</strong></p>
<p>To let two asteroids or two bullets pass each other by without a word of acknowledgement
(or a dramatic explosion), we just need to check if their classes are equal in the
PhysicalObject.handle_collision_with() method:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">handle_collision_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_object</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">other_object</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dead</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dead</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p>There are a few other, more elegant ways to check for object equality in Python, but the above
code gets the job done.</p>
</div>
<div class="section" id="customizing-bullet-collisions">
<h3>Customizing bullet collisions<a class="headerlink" href="#customizing-bullet-collisions" title="Permalink to this headline">¶</a></h3>
<p>Since bullet collision behavior can vary so wildly across objects, let’s add a reacts_to_bullets
attribute to PhysicalObjects which the Bullet class can check to determine if it should register
a collision or not.  We should also add an is_bullet attribute so we can check the collision
properly from both objects.</p>
<p>(These are not “good” design decisions, but they will work.)</p>
<p>First, initialize the reacts_to_bullets attribute to True in the PhysicalObject constructor:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PhysicalObject</span><span class="p">(</span><span class="n">pyglet</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">Sprite</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reacts_to_bullets</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_bullet</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">...</span>

<span class="k">class</span> <span class="nc">Bullet</span><span class="p">(</span><span class="n">physicalobject</span><span class="o">.</span><span class="n">PhysicalObject</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_bullet</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p>Then, insert a bit of code in <cite>PhysicalObject.collides_with()</cite> to ignore bullets under the right
circumstances:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">collides_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_object</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">reacts_to_bullets</span> <span class="ow">and</span> <span class="n">other_object</span><span class="o">.</span><span class="n">is_bullet</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bullet</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other_object</span><span class="o">.</span><span class="n">reacts_to_bullets</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Finally, set self.reacts_to_bullets = False in Player.__init__().  TheBullet` class is completely
finished!  Now let’s make something happen when a bullet hits an asteroid.</p>
</div>
<div class="section" id="making-asteroids-explode">
<h3>Making asteroids explode<a class="headerlink" href="#making-asteroids-explode" title="Permalink to this headline">¶</a></h3>
<p>Asteroids is challenging to players because every time you shoot an asteroid, it turns into more
asteroids.  We need to mimic that behavior if we want our game to be any fun.  We’ve already done
most of the hard parts.  All that remains is to make another subclass of PhysicalObject and write
a custom <cite>handle_collision_with()</cite> method, along with a couple of maintenance tweaks.</p>
</div>
<div class="section" id="writing-the-asteroid-class">
<h3>Writing the asteroid class<a class="headerlink" href="#writing-the-asteroid-class" title="Permalink to this headline">¶</a></h3>
<p>Create a new submodule of game called asteroid.py.  Write the usual constructor to pass a specific
image to the superclass, passing along any other parameters:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyglet</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">resources</span><span class="p">,</span> <span class="n">physicalobject</span>

<span class="k">class</span> <span class="nc">Asteroid</span><span class="p">(</span><span class="n">physicalobject</span><span class="o">.</span><span class="n">PhysicalObject</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Asteroid</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">resources</span><span class="o">.</span><span class="n">asteroid_image</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we need to write a new <cite>handle_collision_with()</cite> method.  It should create a random number of
new, smaller asteroids with random velocities.  However, it should only do that if it’s big enough.
An asteroid should divide at most twice, and if we scale it down by half each time, then an
asteroid should stop dividing when it’s 1/4 the size of a new asteroid.</p>
<p>We want to keep the old behavior of ignoring other asteroids, so start the method with a call to
the superclass’s method:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">handle_collision_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_object</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">Asteroid</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">handle_collision_with</span><span class="p">(</span><span class="n">other_object</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we can say that if it’s supposed to die, and it’s big enough, then we should create two or
three new asteroids with random rotations and velocities.  We should add the old asteroid’s
velocity to the new ones to make it look like they come from the same object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>

<span class="k">class</span> <span class="nc">Asteroid</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">handle_collision_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_object</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Asteroid</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">handle_collision_with</span><span class="p">(</span><span class="n">other_object</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dead</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mf">0.25</span><span class="p">:</span>
            <span class="n">num_asteroids</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_asteroids</span><span class="p">):</span>
                <span class="n">new_asteroid</span> <span class="o">=</span> <span class="n">Asteroid</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch</span><span class="p">)</span>
                <span class="n">new_asteroid</span><span class="o">.</span><span class="n">rotation</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">)</span>
                <span class="n">new_asteroid</span><span class="o">.</span><span class="n">velocity_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">70</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_x</span><span class="p">)</span>
                <span class="n">new_asteroid</span><span class="o">.</span><span class="n">velocity_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">70</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_y</span><span class="p">)</span>
                <span class="n">new_asteroid</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">*</span> <span class="mf">0.5</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">new_objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_asteroid</span><span class="p">)</span>
</pre></div>
</div>
<p>While we’re here, let’s add a small graphical touch to the asteroids by making them rotate a
little.  To do that, we’ll add a rotate_speed attribute and give it a random value.  Then we’ll
write an <cite>update()</cite> method to apply that rotation every frame.</p>
<p>Add the attribute in the constructor:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">Asteroid</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">resources</span><span class="o">.</span><span class="n">asteroid_image</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">rotate_speed</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="o">-</span> <span class="mf">50.0</span>
</pre></div>
</div>
<p>Then write the update() method:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">Asteroid</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">rotation</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_speed</span> <span class="o">*</span> <span class="n">dt</span>
</pre></div>
</div>
<p>The last thing we need to do is go over to load.py and have the asteroid() method create a new
Asteroid instead of a PhysicalObject:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">asteroid</span>

<span class="k">def</span> <span class="nf">asteroids</span><span class="p">(</span><span class="n">num_asteroids</span><span class="p">,</span> <span class="n">player_position</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_asteroids</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="n">new_asteroid</span> <span class="o">=</span> <span class="n">asteroid</span><span class="o">.</span><span class="n">Asteroid</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">asteroid_x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">asteroid_y</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="n">batch</span><span class="p">)</span>
        <span class="o">...</span>
    <span class="k">return</span> <span class="n">asteroids</span>
</pre></div>
</div>
<p>Now we’re looking at something resembling a game.  It’s simple, but all of the basics are there.</p>
</div>
</div>
<div class="section" id="next-steps">
<h2>Next steps<a class="headerlink" href="#next-steps" title="Permalink to this headline">¶</a></h2>
<p>So instead of walking you through a standard refactoring session, I’m going to leave it as an
exercise for you to do the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>* Make the Score counter mean something
* Let the player restart the level if they die
* Implement lives and a “Game Over” screen
* Add particle effects
</pre></div>
</div>
<p>Good luck!  With a little effort, you should be able to figure out most of these things on your own.
If you have trouble, join us on the pyglet mailing list.</p>
<p>Also, in addition to this example game, there is yet <em>another</em> Asteroids clone available in the
<cite>/examples/astraea/</cite> folder in the pyglet source directory.  In comparison to this example game
excercise we’ve just completed, Astraea is a complete game with a proper menu, score system, and
additional graphical effects.  No step-by-step documentation is available for Astraea, but the code
itself should be easy to understand and illustrates some nice techniques.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">In-depth game example</a><ul>
<li><a class="reference internal" href="#basic-graphics">Basic graphics</a><ul>
<li><a class="reference internal" href="#setting-up">Setting up</a></li>
<li><a class="reference internal" href="#getting-a-window">Getting a window</a></li>
<li><a class="reference internal" href="#loading-and-displaying-an-image">Loading and displaying an image</a></li>
<li><a class="reference internal" href="#centering-the-images">Centering the images</a></li>
<li><a class="reference internal" href="#initializing-objects">Initializing objects</a></li>
<li><a class="reference internal" href="#making-the-labels">Making the labels</a></li>
<li><a class="reference internal" href="#drawing-the-labels">Drawing the labels</a></li>
<li><a class="reference internal" href="#making-the-player-and-asteroid-sprites">Making the player and asteroid sprites</a></li>
</ul>
</li>
<li><a class="reference internal" href="#basic-motion">Basic motion</a><ul>
<li><a class="reference internal" href="#drawing-with-batches">Drawing with batches</a></li>
<li><a class="reference internal" href="#displaying-little-ship-icons">Displaying little ship icons</a></li>
<li><a class="reference internal" href="#making-things-move">Making things move</a></li>
<li><a class="reference internal" href="#writing-the-game-update-function">Writing the game update function</a></li>
<li><a class="reference internal" href="#calling-the-update-function">Calling the update() function</a></li>
<li><a class="reference internal" href="#writing-the-player-class">Writing the Player class</a></li>
<li><a class="reference internal" href="#integrating-the-player-class">Integrating the player class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#giving-the-player-something-to-do">Giving the player something to do</a><ul>
<li><a class="reference internal" href="#simplifying-player-input">Simplifying player input</a></li>
<li><a class="reference internal" href="#adding-an-engine-flame">Adding an engine flame</a></li>
<li><a class="reference internal" href="#loading-the-flame-image">Loading the flame image</a></li>
<li><a class="reference internal" href="#creating-and-drawing-the-flame">Creating and drawing the flame</a></li>
<li><a class="reference internal" href="#cleaning-up-after-death">Cleaning up after death</a></li>
<li><a class="reference internal" href="#checking-for-collisions">Checking For collisions</a></li>
<li><a class="reference internal" href="#checking-all-object-pairs">Checking all object pairs</a></li>
<li><a class="reference internal" href="#implementing-the-collision-functions">Implementing the collision functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#collision-response">Collision response</a><ul>
<li><a class="reference internal" href="#adding-objects-during-play">Adding objects during play</a></li>
<li><a class="reference internal" href="#tweaking-the-game-loop">Tweaking the game loop</a></li>
<li><a class="reference internal" href="#putting-the-attribute-in-physicalobject">Putting the attribute in PhysicalObject</a></li>
<li><a class="reference internal" href="#adding-bullets">Adding bullets</a></li>
<li><a class="reference internal" href="#firing-bullets">Firing bullets</a></li>
<li><a class="reference internal" href="#customizing-collision-behavior">Customizing collision behavior</a></li>
<li><a class="reference internal" href="#customizing-bullet-collisions">Customizing bullet collisions</a></li>
<li><a class="reference internal" href="#making-asteroids-explode">Making asteroids explode</a></li>
<li><a class="reference internal" href="#writing-the-asteroid-class">Writing the asteroid class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#next-steps">Next steps</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="advanced.html"
                        title="previous chapter">Advanced topics</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../modules/pyglet.html"
                        title="next chapter">pyglet</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../modules/pyglet.html" title="pyglet"
             >next</a> |</li>
        <li class="right" >
          <a href="advanced.html" title="Advanced topics"
             >previous</a> |</li>
		<li><a href="http://pyglet.org/">pyglet.org</a> |</li>
		<li><a href="../index.html">Documentation Index</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2006-2017, Alex Holkner.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5.
    </div>
  </body>
</html>